
## 문자열 패딩
### `rjust`
- 오른쪽 정렬
- 전체 문자열 길이와 공백을 채울 문자 지정
```python
# 00077
val = '77'.rust(5, "0")
```
### `ljust`
- 왼쪽으로 정렬
- 전체 문자열 길이와 공백을 채울 문자 지정/
```python
# 00222
val = '222'.ljust(5, "0") 
```
### `zfill`
- 주어진 길이가 되도록 0을 왼쪽에 채워줌
```python
# 022
val = '2'.zfill(3)
```
### `deque(maxlen=)`
- maxlen 파라미터는 덱의 최대크기를 지정하며 최대 크기에서 새로운 원소를 append 할 시 가장 오래된 항목(head에 가까운 노드)부터 제거한다
```python
q = deque(maxlen=3)
q.append(1)
q.append(2)
q.append(3)
q.append(4)
# deque([2, 3, 4])
q.appendleft(5)
# deque([5, 2, 3])
```
## 정렬
- Python, C++은 기본 정렬 메소드가 모두 stable sort를 지원한다.
- merge sort, bubble sort, insertion sort가 모두 stable sort이다.
- stable sort를 만들기 위해서 *decorate-sort-undecorate*패턴을 사용하기도 한다.
	- *순서를 나타내는 추가적인 키를 추가하여 sorting후에 original value를 순서대로 추출하는 패턴*

## 정규표현식

### 긍정형 전방탐색
- `(?=정규식)`를 사용해서 정규표현식을 매칭한후 정규식과 매칭된 해당 문자열을 소비하지 않고 다시 그 부분부터 매칭한다
### 부정형 전방탐색
- `(?=정규식))`를 사용해서 정규식과 매칭하지 않아야 매칭되고 해당 문자열을 소비하지 않는다.
### 정규표현식을 통한 문자열 치환
```python
p = re.compile('[.]{2,}') # .이 2번 이상 연속된 문자열 매칭
s = p.sub('.', 'aa..bb...c')
# s = aa.bb.c
```
- `sub`메서드를 이용하여 첫번째 매개변수는 바꿀 문자열을 넣고 두번째 매개변수는 대상 문자열을 넣는다.
- 매칭하는 첫번째만 바꿀 경우는 `count=1`과 같이 추가 매개변수 `count`를 사용하여 바꿀 횟수를 지정할 수 있다.
### re 메소드
- `match`: 문자열 처음부터 매칭하는지
- `search`: 문자열 아무곳에서 매칭하는지
- `findall`: 매칭하는 모든것을 리스트로 리턴
- `split`: 해당 regex구분자를 통해 split한 문자열들을 리스트로 리턴

# 언어별 주의사항
## Python
- `map`은 lazy evaluation을 사용하므로 `list(map(람다, ...))` 과 같이 바로 리스트화 하지 않으면 안의 람다함수가 실행되지 않는다.
- 파이썬의 음수의 몫은 내림을 사용하고, 자바는 버림을 사용한다. 따라서 자바에서 왼쪽방향의 순환이동을 계산할때는 (나머지 결과 + 주기(원형큐사이즈))%주기(원형큐사이즈)로 계산한다.

# 후위 표기식
## 중위 표기법을 후위 표기법으로 변환
  **1) 피연산자가 들어오면 바로 출력한다.**  
  **2) 연산자가 들어오면 자기보다 우선순위가 높거나 같은 것들을 빼고 자신을 스택에 담는다.**   
  **3) 여는 괄호 '('를 만나면 무조건 스택에 담는다.**   
  **4) 닫는 괄호 ')'를 만나면 '('를 만날 때까지 스택에서 출력한다.**   

## **후위 표기법 계산**
  **1) 피연산자를 만나면 스택에 담는다.**  
  **2) 연산자를 만나면 스택에서 두 개의 연산자를 꺼내서 연산한 뒤에 그 결과를 스택에 담는다.**   
  **3) 연산을 마치고 스택에 남아있는 하나의 피연산자가 연산 수행 결과이다.**  